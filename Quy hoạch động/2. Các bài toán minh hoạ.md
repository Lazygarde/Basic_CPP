# Bài 1
[HISO - Hiệu số](http://ntucoder.net/Problem/Details/73)
* Yêu cầu: Cho một dãy có `n` phần tử. Hãy tìm hai chỉ số `i`, `j` sao cho `i < j` và hiệu `aj - ai` là lớn nhất.
* Ý tưởng:
  - Cách 1: 
    Duyệt tất cả các cặp `(i, j)` và tìm cặp có hiệu lớn nhất.
    > Độ phức tạp `O(n^2)`.
  - Cách 2:
    Duyệt từ trái qua phải và lưu lại giá trị nhỏ nhất hiện tại. Từ đó ta có thể tính được hiệu lớn nhất.
    > Độ phức tạp `O(n)`.
* Chi tiết thuật toán:
  |index| 1| 2|3|4|5|
  |---|---|---|---|---|---|
  |a|2|5|1|4|6|

  - Với mỗi vị trí `i`, với cách thông thường là sẽ duyệt từ `1` đến `i - 1` để tìm giá trị nhỏ nhất.
  - Nhưng với cách 2 thì ta sẽ lưu giá trị nhỏ nhất sau mỗi lần duyệt. Từ đó ta có thể tính được hiệu lớn nhất.

  |index| 1| 2|3|4|5|
  |---|---|---|---|---|---|
  |a|2|5|1|4|6|
  |minVal|2|2|1|1|1|
  |diff|0|3|4|3|5|

  Vậy ta có thể thấy hiệu lớn nhất là `5`.
* Code:
  ```cpp
  int n;
  cin >> n;
  int a[n + 1], b[n + 1];
  b[0] = 1e9;
  int ans = 0;
  for (int i = 1; i <= n; i++) {
      cin >> a[i];
      b[i] = min(b[i - 1], a[i]);
      ans = max(ans, a[i] - b[i]);
  }
  cout << ans;
  ```
# Bài 2
[BANHCHUNG - Nấu bánh chưng](http://ntucoder.net/Problem/Details/5518)
* Yêu cầu: Tìm tổng dãy con lớn nhất, nhỏ hơn `m`.
* Ý tưởng:
  - Ta cần 1 mảng đánh dấu tất cả các tổng dãy con có thể có.
  - Gọi `f[]` là mảng đánh dấu kết quả. `f[i] = 1` nếu tồn tại dãy con có tổng bằng `i`. `f[i] = 0` nếu không tồn tại.
* Chi tiết thuật toán:
  - Duyệt từng phần tử của dãy `a[]`.
  - Với mỗi phần tử a[i], ta đánh dấu tất cả các tổng có thể có từ những phần đã đánh dấu.
  - Ví dụ: a[] = {6, 7, 1, 9}
    - Sau khi xét i = 2 thì mảng f[] có giá trị như sau:
    
      |index|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|
      |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
      |f|0|0|0|0|0|1|1|0|0|0|0|0|1|0|0|
    - Khi xét đến i = 1 thì mảng f[] sẽ cập nhập các vị trí có thể tạo thành tổng của dãy con là 6 + 1, 7 + 1, 13 + 1.
      |index|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|
      |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
      |f|0|0|0|0|0|1|1|1|0|0|0|0|1|1|0|
  - Công thức: `if(f[j - a[i]] == 1) f[j] = 1`;
* Code:
  ```cpp
  int n, m;
  cin >> m >> n;
  int a[n + 1], f[m + 1];
  for (int i = 1; i <= n; i++) {
      cin >> a[i];
  }
  for (int i = 1; i <= n; i++) {
      f[a[i]] = 1;
      for (int j = a[i] + 1; j <= m; j++) {
          if (f[j - a[i]]) {
              f[j] = 1;
          }
      }
  }
  for (int i = m; i >= 0; i--) {
      if (f[i]) {
          cout << i << '\n';
          break;
      }
  }
  ```

# Bài 3
[CATU2 - Cái túi 2](http://ntucoder.net/Problem/Details/1148)
* Yêu cầu: Tìm dãy con có tổng giá trị lớn nhất, nhưng tổng khối lượng nhỏ hơn m.
* Ý tưởng: Gọi f[] là mảng lưu kết quả. f[i] là tổng giá trị lớn nhất có thể có khi cái túi có khối lượng là i.
* Chi tiết thuật toán:
  - Duyệt từng phần tử của dãy a[].
  - Với mỗi phần tử a[i], ta có 2 lựa chọn là đưa phần tử này vào túi hoặc không đưa vào. Và ta thực hiện lựa chọn nào có giá trị lớn hơn.
  - Ví dụ:
    ```
    n = 5, m = 11
    ```
    |weight| value|
    |---|---|
    |3|3|
    |4|4|
    |5|4|
    |9|10|
    |4|5|
    - Sau khi xét i = 1 thì mảng f[] có giá trị như sau:
    
      |index|1|2|3|4|5|6|7|8|9|10|11|
      |---|---|---|---|---|---|---|---|---|---|---|---|
      |f|0|0|3|3|3|3|3|3|3|3|3|
    - Khi xét đến i = 2 thì mảng f[] sẽ cập nhập các vị trí nếu chọn phần tử thứ 2.

      |index|1|2|3|4|5|6|7|8|9|10|11|
      |---|---|---|---|---|---|---|---|---|---|---|---|
      |f|0|0|3|4|4|4|7|7|7|7|7|
  - Công thức: `f[i] = max(f[i], f[i - a[i].weight] + a[i].value)`
* Code:
  ```cpp
  int n, m;
  cin >> n >> m;
  int w[n + 1], v[n + 1];
  for (int i = 1; i <= n; i++) {
      cin >> w[i] >> v[i];
  }
  int f[m + 1] = {};
  for (int i = 1; i <= n; i++) {
      for (int j = m; j >= 1; j--) {
          if (j >= w[i]) {
              f[j] = max(f[j], f[j - w[i]] + v[i]);
          }
      }
  }
  cout << f[m];
  ```
* Mở rộng: Bài toán yêu cần cần in ra dãy con đáp án.
  - Cách giải quyết: Tạo thêm 1 vector 2 chiều a[] để lưu các phần tử đã được chọn vào túi. a[i] là vector chứa các phần tử đã được chọn vào túi khi khối lượng của túi là i.
  - Code:
    ```cpp
    int n, m;
    cin >> n >> m;
    int w[n + 1], v[n + 1];
    for (int i = 1; i <= n; i++) {
        cin >> w[i] >> v[i];
    }
    int dp[m + 1] = {};
    vector<vector<int>> a(10001);
    for (int i = 1; i <= n; i++) {
        for (int j = m; j >= 1; j--) {
            if (j >= w[i]) {
                if(dp[j] < dp[j - w[i]] + v[i]) {
                    dp[j] = dp[j - w[i]] + v[i];
                    a[j] = a[j - w[i]];
                    a[j].push_back(i);
                }
            }
        }
    }
    cout << dp[m] << '\n';
    for (auto i : a[m]) {
        cout << i << ' ';
    }
    ```
# Bài 4
[Capxach - Cặp xách](http://ntucoder.net/Problem/Details/5568)
* Yêu cầu: Từ dãy số có n phần tử, hãy đếm số cách tạo thành dãy số có tổng bằng m. (Phần tử có sử dụng lại nhiều lần).

  ```
  n = 3, m = 4
  a[] = {1, 2, 3}
  ```
  > Đáp án là 4: {1, 1, 1, 1}, {1, 1, 2}, {1, 3}, {2, 2}
* Ý tưởng: Gọi f[] là mảng lưu kết quả. f[i] là số cách tạo thành dãy số có tổng bằng i.
  |index|1|2|3|4|
  |---|---|---|---|---|
  |f|1|2|3|4|
  |Chi tiết|`1`|`1 1`, `2`|`1 1 1`, `1 2`, `3`|`1 1 1 1`, `1 1 2`, `1 3`, `2 2`|
* Chi tiết thuật toán:
  - Duyệt từ `1` đến `n`, với mỗi phần tử thứ i ta cập nhập mảng `f[]`.
  - Với mỗi `a[i]`, duyệt `j` từ `a[i] -> m`. Công thức: `f[j] += f[j - a[i]]`
  - Độ phức tạp: `O(n * m)`
  - Ví dụ:
    - Sau khi duyệt `i = 1`, mảng f[] sẽ nhận giá trị như sau:

      |index|1|2|3|4|
      |---|---|---|---|---|
      |f|1|1|1|1|
      |Chi tiết|`1`|`1 1`|`1 1 1`|`1 1 1 1`|
    - Khi duyệt đến `i = 2`, `f[3]` sẽ nhận thêm giá trị của f[3 - a[2]] = f[1] = 1. Tương ứng với việc nhận thêm tất cả những dãy số có tổng bằng 1 cộng thêm giá trị a[2]. => f[3] = 2
    - f[4] sẽ nhận thêm giá trị của f[4 - a[2]] = f[2] = 2. Tương ứng với việc nhận thêm tất cả những dãy số có tổng bằng 2 cộng thêm giá trị a[2]. => f[4] = 3
    - Như vậy, sau khi duyệt `i = 2` thì mảng f[] sẽ nhận giá trị như sau:

      |index|1|2|3|4|
      |---|---|---|---|---|
      |f|1|1|2|3|
      |Chi tiết|`1`|`1 1`, `2`|`1 1 1`, `1 2`|`1 1 1 1`, `1 1 2`, `2 2`|
* Code:
    ```cpp
    int n, k;
    cin >> k >> n;
    int a[n + 1];
    long long f[k + 1] = {};
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    f[0] = 1;
    for (int i = 1; i <= n; i++) {
        for (int j = a[i]; j <= k; j++) {
            f[j] += f[j - a[i]];
        }
    }
    cout << f[k];
    ```
# Bài 5
[DACO - Dãy con tăng dài nhất](http://ntucoder.net/Problem/Details/78)
* Yêu cầu: Cho một dãy có n phần tử. Hãy tìm dãy con tăng dài nhất.
* Ý tưởng: Gọi f[] là mảng lưu kết quả, f[i] là độ dài dãy con tăng dài nhất kết thúc tại i.

    |index|1|2|3|4|5|6|
    |---|---|---|---|---|---|---|
    |a|1| 2| 5| 7| 6| 2|
    |f|1| 2| 3| 3| 4| 2|
* Chi tiết thuật toán:
  - Duyệt từ 1 đến n, với mỗi i, duyệt từ 1 đến i-1, nếu a[j] < a[i] thì f[i] = max(f[i], f[j] + 1). Bởi vì nếu a[j] < a[i] thì ta có thể thêm a[i] vào dãy con tăng dài nhất kết thúc tại j để tạo thành dãy con tăng dài nhất kết thúc tại i.
  - Độ phức tạp: O(n^2).
  - Ví dụ 1 trạng thái:
    Khi xét đến i = 5, ta duyệt lần lượt j từ 1 -> 4
    - j = 1: 
      > Dãy con tăng kết thúc tại 1: 1

      a[1] < a[5] => Dãy con tăng kết thúc tại 5 có thể được tạo thành bằng cách thêm a[5] vào dãy con tăng dài nhất kết thúc tại 1 => f[5] = max(f[5], f[1] + 1) = max(1, 1 + 1) = 2.
    - j = 2:
      > Dãy con tăng kết thúc tại 2: 1 2

      a[2] < a[5] => Dãy con tăng kết thúc tại 5 có thể được tạo thành bằng cách thêm a[5] vào dãy con tăng dài nhất kết thúc tại 2 => f[5] = max(f[5], f[2] + 1) = max(2, 2 + 1) = 3.
    - j = 3:
      > Dãy con tăng kết thúc tại 3: 1 2 5

      a[3] < a[5] => Dãy con tăng kết thúc tại 5 có thể được tạo thành bằng cách thêm a[5] vào dãy con tăng dài nhất kết thúc tại 3 => f[5] = max(f[5], f[3] + 1) = max(3, 3 + 1) = 4.
    - j = 4:
      > Dãy con tăng kết thúc tại 4: 1 2 5 7

      a[4] > a[5] => Không thể tạo thành dãy con tăng dài nhất kết thúc tại 5 bằng cách thêm a[5] vào dãy con tăng dài nhất kết thúc tại 4.
  * Code:
    ```cpp
    int n;
    cin >> n;
    int a[n + 1], f[n + 1], ans = 1;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    for (int i = 1; i <= n; i++) {
        f[i] = 1;
        for (int j = 1; j < i; j++) {
            if (a[j] < a[i]) {
                f[i] = max(f[i], f[j] + 1);
            }
        }
        ans = max(ans, f[i]);
    }
    cout << ans;
    ```
* Mở rộng: Bài toán yêu cầu phải in ra dãy con tăng dài nhất bất kỳ.
  - Ý tưởng: Ta sử dụng một mảng truy hồi để lưu lại vị trí của phần tử trước đó của dãy con tăng dài nhất kết thúc tại i.
  - VD: 
    |index|1|2|3|4|5|6|
    |---|---|---|---|---|---|---|
    |a|1| 2| 5| 7| 6| 2|
    |f|1| 2| 3| 3| 4| 2|
    |th(truy hồi)|0| 1| 2| 3| 3| 1|
    
    - Với mỗi th[i] = j, ta có thể tìm được dãy con tăng dài nhất kết thúc tại i bằng cách duyệt ngược từ i đến j, với mỗi j, ta duyệt ngược từ j đến th[j].

    - Vì dãy con tăng dài nhất kết thúc tại 4 => Dãy truy hồi hiện tại: 6

    - th[4] = 3 => Dãy truy hồi hiện tại: 6 - 5

    - th[3] = 2 => Dãy truy hồi hiện tại: 6 - 5 - 2
    - th[2] = 1 => Dãy truy hồi hiện tại: 6 - 5 - 2 - 1

    > Vậy dãy con tăng dài nhất kết thúc tại 4 là: 1 2 5 6
  - Code:
    ```cpp
    int n;
    cin >> n;
    int a[n + 1], b[n + 1], c[n + 1] = {}, ans = 0, p;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    for (int i = 1; i <= n; i++) {
        b[i] = 1;
        for (int j = 1; j < i; j++) {
            if (a[j] < a[i] && b[j] + 1 > b[i]) {
                b[i] = b[j] + 1;
                c[i] = j;
            }
        }
        if (b[i] > ans) {
            ans = b[i];
            p = i;
        }
    }
    cout << ans << endl;
    stack<int> s;
    while (p) {
        s.push(a[p]);
        p = c[p];
    }
    while (!s.empty()) {
        cout << s.top() << " ";
        s.pop();
    }
    ```
# Bài 6
[THIDAU - Kế hoạch thi đấu](http://ntucoder.net/Problem/Details/2250)
* Yêu cầu:

  Tính tổng giải thưởng lớn nhất có thể với các ngày thi đấu cách nhau ít nhất `k` ngày.
  ```
  n = 5, k = 2
  a[] = {1, 2, 3, 4, 5}
  b[] = {1, 3, 2, 1, 1}
  ```
  > Đáp án: 4, có 2 cách chọn là chọn ngày 1, 3, 5 hoặc ngày 2, 4.
* Ý tưởng:
  - Gọi `f[]` là mảng lưu kết quả. `f[i]` là tổng giải thưởng lớn nhất khi xét đến ngày thứ `i` và chọn `i` là ngày thi đấu cuối cùng.
  - Duyệt 2 vòng for từ `1 -> n`. Nếu `a[i] - a[j] >= k` thì `f[i] = max(f[i], f[j] + b[i])`.
* Chi tiết thuật toán:
  - Thuật toán khá giống bài [DACO - Dãy con tăng dài nhất](http://ntucoder.net/Problem/Details/78).
  - VD sau khi duyệt i = 3.
    |index|1|2|3|4|5|
    |---|---|---|---|---|---|
    |a|1| 2| 3| 4| 5|
    |b|1| 3| 2| 1| 1|
    |f|1| 3|3|x|x|
  - Khi duyệt đến i = 4, ta sẽ chọn ngày thứ 4 là ngày thi đấu cuối cùng. Giá trị của `f[4]` = max(`b[4] + f[1]`, `b[4] + f[2]`) = `4`.
    |index|1|2|3|4|5|
    |---|---|---|---|---|---|
    |a|1| 2| 3| 4| 5|
    |b|1| 3| 2| 1| 1|
    |f|1| 3|3|4|x|
* Code: 
    ```cpp
    int n, k;
    cin >> n >> k;
    int a[n + 1], b[n + 1], f[n + 1];
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    for (int i = 1; i <= n; i++)
        cin >> b[i];
    int ans = 0;
    for (int i = 1; i <= n; i++) {
        f[i] = b[i];
        for (int j = 1; j < i; j++) {
            if (a[i] - a[j] >= k) {
                f[i] = max(f[i], f[j] + b[i]);
            }
        }
        ans = max(ans, f[i]);
    }
    cout << ans;
    ```
